<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Jumping Ball Runner</title>
    <style>
      :root {
        --bg: #081325;
        --panel: rgba(255, 255, 255, 0.07);
        --accent: #ff8f2f;
        --accent-dark: #ec4cab;
        --text: #fefefe;
      }

      * {
        box-sizing: border-box;
      }

      body {
        margin: 0;
        min-height: 100vh;
        background: radial-gradient(circle at top, #1e2a5b, #050710 65%);
        color: var(--text);
        font-family: "Baloo 2", "Comic Sans MS", "Poppins", sans-serif;
        display: flex;
        align-items: center;
        justify-content: center;
        padding: 2rem 1rem;
      }

      button {
        font-family: inherit;
        border: none;
        cursor: pointer;
      }

      .game-shell {
        width: min(1100px, 96vw);
        background: rgba(255, 255, 255, 0.02);
        border-radius: 24px;
        border: 2px solid rgba(255, 255, 255, 0.12);
        box-shadow: 0 30px 60px rgba(3, 4, 29, 0.65);
        padding: clamp(1rem, 4vw, 2rem);
      }

      .hud {
        display: flex;
        flex-wrap: wrap;
        align-items: center;
        justify-content: space-between;
        gap: 1rem;
        margin-bottom: 1rem;
      }

      .hud .title {
        font-size: clamp(1.5rem, 4vw, 2.6rem);
        display: flex;
        align-items: baseline;
        gap: 0.8rem;
      }

      .hud .title span {
        font-size: clamp(0.9rem, 2vw, 1.2rem);
        color: #ffda65;
        text-transform: uppercase;
        letter-spacing: 0.12em;
      }

      .metrics {
        display: flex;
        gap: 1rem;
        flex-wrap: wrap;
      }

      .metric {
        background: var(--panel);
        border-radius: 14px;
        padding: 0.6rem 1rem;
        text-align: center;
        min-width: 110px;
        border: 1px solid rgba(255, 255, 255, 0.1);
      }

      .metric small {
        display: block;
        font-size: 0.7rem;
        text-transform: uppercase;
        letter-spacing: 0.12em;
        color: rgba(255, 255, 255, 0.7);
      }

      .metric strong {
        font-size: 1.5rem;
      }

      .game-area {
        position: relative;
        width: 100%;
        height: clamp(420px, 55vw, 540px);
        background: linear-gradient(#2d1b64, #20184a 45%, #15112d);
        overflow: hidden;
        border-radius: 22px;
        border: 2px solid rgba(255, 255, 255, 0.07);
        box-shadow: inset 0 0 25px rgba(0, 0, 0, 0.3);
        touch-action: manipulation;
      }

      .layer {
        position: absolute;
        inset: 0;
        background-repeat: repeat-x;
        animation: slide 30s linear infinite;
        pointer-events: none;
      }

      .layer.stars {
        background-image: radial-gradient(rgba(255, 255, 255, 0.7) 1px, transparent 1px),
          radial-gradient(rgba(255, 255, 255, 0.4) 1px, transparent 1px);
        background-size: 120px 120px, 200px 200px;
        background-position: 0 0, 50px 80px;
        opacity: 0.4;
        animation-duration: 120s;
      }

      .layer.clouds {
        background-image: url("data:image/svg+xml,%3Csvg width='160' height='80' viewBox='0 0 160 80' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M20 50c0-15 20-25 30-12 0-17 24-26 40-14 5-13 26-21 40-9 13-9 30-5 30 13 0 18-18 34-40 34H40C26 62 20 61 20 50z' fill='%23ffffff' fill-opacity='.25'/%3E%3C/svg%3E");
        background-size: 320px auto;
        animation-duration: 70s;
        top: -40px;
      }

      .layer.hills {
        background-image: radial-gradient(circle at 20% 80%, #5faf36, transparent 55%),
          radial-gradient(circle at 60% 75%, #47761d, transparent 55%),
          radial-gradient(circle at 90% 80%, #5faf36, transparent 55%);
        background-size: 400px 400px;
        opacity: 0.8;
        animation-duration: 50s;
        bottom: 65px;
      }

      .layer.city {
        background-image: url("data:image/svg+xml,%3Csvg width='200' height='120' xmlns='http://www.w3.org/2000/svg'%3E%3Crect width='40' height='120' x='10' y='0' fill='%232d3561'/%3E%3Crect width='60' height='80' x='70' y='40' fill='%233a4271'/%3E%3Crect width='50' height='100' x='140' y='20' fill='%2327364f'/%3E%3C/svg%3E");
        background-size: 220px auto;
        opacity: 0.55;
        animation-duration: 35s;
        bottom: 80px;
      }

      @keyframes slide {
        from {
          background-position-x: 0;
        }
        to {
          background-position-x: -1000px;
        }
      }

      .ground {
        position: absolute;
        left: 0;
        bottom: 0;
        width: 100%;
        height: 95px;
        background: repeating-linear-gradient(
            60deg,
            rgba(255, 255, 255, 0.07),
            rgba(255, 255, 255, 0.07) 30px,
            rgba(0, 0, 0, 0.15) 30px,
            rgba(0, 0, 0, 0.15) 60px
          ),
          linear-gradient(180deg, #ff9a44, #ff4f8e);
        border-top: 4px solid rgba(0, 0, 0, 0.25);
      }

      .player {
        position: absolute;
        width: 78px;
        height: 78px;
        border-radius: 50%;
        background: radial-gradient(circle at 30% 30%, #fff5d0, #ff7b74 60%, #ff4f8e);
        border: 4px solid rgba(0, 0, 0, 0.2);
        bottom: 95px;
        filter: drop-shadow(0 10px 10px rgba(0, 0, 0, 0.3));
        transition: transform 0.2s;
      }

      .player-face {
        position: absolute;
        inset: 0;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        gap: 4px;
      }

      .eyes {
        display: flex;
        gap: 12px;
      }

      .eye {
        width: 16px;
        height: 20px;
        border-radius: 50%;
        background: #fff;
        display: inline-flex;
        align-items: center;
        justify-content: center;
        position: relative;
        overflow: hidden;
      }

      .eye::after {
        content: "";
        width: 8px;
        height: 10px;
        border-radius: 50%;
        background: #1b2049;
        position: absolute;
        top: 5px;
      }

      .smile {
        width: 40px;
        height: 20px;
        border-bottom: 4px solid #1b2049;
        border-radius: 0 0 50px 50px;
      }

      .player.cheer .smile {
        border-bottom-color: #fff;
      }

      .obstacle {
        position: absolute;
        bottom: 95px;
        border-radius: 14px 14px 8px 8px;
        background: #24cbc9;
        border: 4px solid rgba(0, 0, 0, 0.25);
        display: flex;
        align-items: center;
        justify-content: center;
        flex-direction: column;
        padding-bottom: 8px;
      }

      .obstacle-face {
        display: flex;
        flex-direction: column;
        gap: 3px;
        align-items: center;
      }

      .obstacle-face .eyes span {
        width: 13px;
        height: 13px;
        border-radius: 50%;
        background: rgba(0, 0, 0, 0.7);
      }

      .obstacle-face .mouth {
        width: 28px;
        height: 10px;
        border-radius: 50% / 70%;
        background: rgba(0, 0, 0, 0.7);
      }

      .message {
        position: absolute;
        top: 1.2rem;
        left: 50%;
        transform: translateX(-50%);
        padding: 0.8rem 1.4rem;
        border-radius: 999px;
        background: rgba(5, 3, 27, 0.65);
        font-size: 1rem;
        letter-spacing: 0.04em;
        text-align: center;
        border: 1px dashed rgba(255, 255, 255, 0.4);
        transition: opacity 0.3s ease;
      }

      .message.hidden {
        opacity: 0;
      }

      .retry {
        position: absolute;
        left: 50%;
        top: 55%;
        transform: translate(-50%, -50%);
        padding: 0.8rem 2rem;
        background: linear-gradient(120deg, #ffcd3c, #ff764d);
        color: #1b0841;
        font-size: 1.2rem;
        border-radius: 999px;
        box-shadow: 0 15px 25px rgba(0, 0, 0, 0.35);
      }

      .retry.hidden {
        display: none;
      }

      .footer-note {
        margin-top: 1.2rem;
        background: var(--panel);
        padding: 0.9rem 1.2rem;
        border-radius: 18px;
        border: 1px solid rgba(255, 255, 255, 0.08);
        font-size: 0.95rem;
        line-height: 1.4;
      }

      .badge {
        font-size: 0.75rem;
        letter-spacing: 0.1em;
        text-transform: uppercase;
        padding: 0.4rem 0.7rem;
        border-radius: 999px;
        background: rgba(255, 255, 255, 0.09);
        border: 1px solid rgba(255, 255, 255, 0.15);
      }

      @media (max-width: 720px) {
        .metric strong {
          font-size: 1.2rem;
        }
      }
    </style>
  </head>
  <body>
    <div class="game-shell">
      <header class="hud">
        <div class="title">
          Jumping Ball Runner
        </div>
        <div class="metrics">
          <div class="metric">
            <small>score</small>
            <strong id="score">0</strong>
          </div>
          <div class="metric">
            <small>high score</small>
            <strong id="high-score">0</strong>
          </div>
          <div class="metric">
            <small>speed</small>
            <strong id="speed">0</strong>
          </div>
        </div>
      </header>
      <div class="game-area" id="game">
        <div class="layer stars"></div>
        <div class="layer clouds"></div>
        <div class="layer hills"></div>
        <div class="layer city"></div>
        <div class="player" id="player">
          <div class="player-face">
            <div class="eyes">
              <span class="eye"></span>
              <span class="eye"></span>
            </div>
            <div class="smile"></div>
          </div>
        </div>
        <div class="message" id="message">
          Tap / click / press Space to jump and dodge giggle-crates!
        </div>
        <button class="retry hidden" id="retry">Retry</button>
        <div class="ground"></div>
      </div>
      <div class="footer-note">
        Stay airborne, keep the energy alive, and chase ridiculous high scores. The runner speeds
        up over time, obstacles get cheekier, and sounds celebrate each action.
      </div>
    </div>

    <script>
      (() => {
        const doc = document;
        const gameArea = doc.getElementById("game");
        const playerEl = doc.getElementById("player");
        const scoreEl = doc.getElementById("score");
        const highScoreEl = doc.getElementById("high-score");
        const speedEl = doc.getElementById("speed");
        const messageEl = doc.getElementById("message");
        const retryBtn = doc.getElementById("retry");

        const storageKey = "jumping-ball-runner-highscore";
        const savedHighScore = parseFloat(localStorage.getItem(storageKey) || "0");

        const state = {
          playing: false,
          gameOver: false,
          score: 0,
          highScore: savedHighScore,
          elapsed: 0,
          speed: 0,
          baseSpeed: 7.5,
          spawnTimer: 0,
        };

        const config = {
          gravity: -3200,
          jumpForce: 1250,
          groundHeight: 95,
          gameWidth: () => gameArea.clientWidth || 900,
        };

        const player = {
          x: 120,
          width: 78,
          height: 78,
          y: 0,
          velocity: 0,
          xRatio: 0.14,
        };

        const obstacles = [];
        let lastTimestamp = 0;
        let audioCtx = null;
        let audioReady = false;

        const soundShapes = {
          jump: { type: "sine", freq: [480, 620], duration: 0.2, volume: 0.2 },
          spawn: { type: "triangle", freq: [260, 220], duration: 0.18, volume: 0.12 },
          score: { type: "square", freq: [720, 870], duration: 0.15, volume: 0.16 },
          crash: { type: "sawtooth", freq: [190, 80], duration: 0.35, volume: 0.25 },
          retry: { type: "triangle", freq: [340, 540], duration: 0.25, volume: 0.18 },
        };

        const formatScore = (n) => Math.floor(n).toString();
        const scoreboardCache = {
          score: "",
          high: "",
          speed: "",
        };

        function unlockAudio() {
          if (audioReady) return;
          const Ctx = window.AudioContext || window.webkitAudioContext;
          if (!Ctx) {
            audioReady = false;
            return;
          }
          audioCtx = audioCtx || new Ctx();
          if (audioCtx.state === "suspended") {
            audioCtx.resume();
          }
          audioReady = true;
        }

        function playSound(name) {
          if (!audioReady || !audioCtx || !soundShapes[name]) return;
          const preset = soundShapes[name];
          const osc = audioCtx.createOscillator();
          const gain = audioCtx.createGain();
          const now = audioCtx.currentTime;
          osc.type = preset.type;
          osc.frequency.setValueAtTime(preset.freq[0], now);
          if (preset.freq[1]) {
            osc.frequency.exponentialRampToValueAtTime(
              Math.max(preset.freq[1], 40),
              now + preset.duration
            );
          }
          gain.gain.setValueAtTime(preset.volume, now);
          gain.gain.exponentialRampToValueAtTime(0.001, now + preset.duration);
          osc.connect(gain).connect(audioCtx.destination);
          osc.start(now);
          osc.stop(now + preset.duration);
        }

        function updateScoreboard() {
          const scoreText = formatScore(state.score);
          const highText = formatScore(state.highScore);
          const speedText = state.speed.toFixed(1);
          if (scoreboardCache.score !== scoreText) {
            scoreboardCache.score = scoreText;
            scoreEl.textContent = scoreText;
          }
          if (scoreboardCache.high !== highText) {
            scoreboardCache.high = highText;
            highScoreEl.textContent = highText;
          }
          if (scoreboardCache.speed !== speedText) {
            scoreboardCache.speed = speedText;
            speedEl.textContent = speedText;
          }
        }

        function syncPlayerX() {
          const width = config.gameWidth();
          player.x = Math.max(60, width * player.xRatio);
          playerEl.style.left = player.x + "px";
        }

        function resetGame() {
          obstacles.forEach((o) => o.el.remove());
          obstacles.length = 0;
          state.score = 0;
          state.elapsed = 0;
          state.speed = state.baseSpeed;
          state.spawnTimer = 0;
          state.playing = false;
          state.gameOver = false;
          player.y = 0;
          player.velocity = 0;
          syncPlayerX();
          playerEl.style.bottom = config.groundHeight + "px";
          playerEl.classList.remove("cheer");
          retryBtn.classList.add("hidden");
          messageEl.textContent = "Tap / click / press Space to jump and dodge giggle-crates!";
          messageEl.classList.remove("hidden");
          updateScoreboard();
        }

        function startRun() {
          if (state.playing) return;
          if (state.gameOver) resetGame();
          state.playing = true;
          messageEl.classList.add("hidden");
        }

        function triggerGameOver() {
          state.playing = false;
          state.gameOver = true;
          retryBtn.classList.remove("hidden");
          messageEl.textContent = "Bonk! Hit Retry to dance again.";
          messageEl.classList.remove("hidden");
          playSound("crash");
          if (state.score > state.highScore) {
            state.highScore = state.score;
            localStorage.setItem(storageKey, String(Math.floor(state.highScore)));
            messageEl.textContent = "New record! Hit Retry for another lap.";
            playerEl.classList.add("cheer");
            playSound("score");
          }
          updateScoreboard();
        }

        function jump() {
          if (state.gameOver) return;
          if (!state.playing) startRun();
          if (player.y <= 2) {
            player.velocity = config.jumpForce;
            playSound("jump");
          }
        }

        function spawnObstacle() {
          const width = 50 + Math.random() * 70;
          const height = 55 + Math.random() * 80;
          const colorHue = Math.floor(Math.random() * 360);
          const obstacle = {
            width,
            height,
            x: config.gameWidth(),
            el: doc.createElement("div"),
            scored: false,
          };
          obstacle.el.className = "obstacle";
          obstacle.el.style.width = width + "px";
          obstacle.el.style.height = height + "px";
          obstacle.el.style.background = `linear-gradient(140deg, hsl(${colorHue},80%,65%), hsl(${colorHue},70%,45%))`;
          obstacle.el.style.left = obstacle.x + "px";
          obstacle.el.innerHTML = `
            <div class="obstacle-face">
              <div class="eyes">
                <span></span>
                <span></span>
              </div>
              <div class="mouth"></div>
            </div>
          `;
          gameArea.appendChild(obstacle.el);
          obstacles.push(obstacle);
          playSound("spawn");
        }

        function removeObstacle(obstacle, index) {
          obstacle.el.remove();
          obstacles.splice(index, 1);
        }

        function detectCollision(obstacle) {
          const playerLeft = player.x;
          const playerRight = player.x + player.width;
          const playerBottom = config.groundHeight + player.y;
          const playerTop = playerBottom + player.height;

          const obstacleLeft = obstacle.x;
          const obstacleRight = obstacle.x + obstacle.width;
          const obstacleBottom = config.groundHeight;
          const obstacleTop = config.groundHeight + obstacle.height;

          const overlapX = playerLeft < obstacleRight && playerRight > obstacleLeft;
          const overlapY = playerBottom < obstacleTop && playerTop > obstacleBottom;
          return overlapX && overlapY;
        }

        function updatePlayer(dt) {
          player.velocity += config.gravity * dt;
          player.y += player.velocity * dt;
          if (player.y < 0) {
            player.y = 0;
            player.velocity = 0;
          }
          playerEl.style.bottom = config.groundHeight + player.y + "px";
        }

        function updateObstacles(dt) {
          const gameWidth = config.gameWidth();
          state.spawnTimer -= dt;
          const spawnDelay = Math.max(0.55, 1.6 - state.elapsed * 0.08);
          if (state.spawnTimer <= 0) {
            spawnObstacle();
            state.spawnTimer = spawnDelay;
          }

          for (let i = obstacles.length - 1; i >= 0; i--) {
            const obstacle = obstacles[i];
            obstacle.x -= state.speed * (220 * dt);
            obstacle.el.style.left = obstacle.x + "px";
            if (!obstacle.scored && obstacle.x + obstacle.width < player.x) {
              state.score += 6;
              obstacle.scored = true;
              playSound("score");
            }
            if (obstacle.x + obstacle.width < -50) {
              removeObstacle(obstacle, i);
            } else if (detectCollision(obstacle)) {
              triggerGameOver();
              break;
            }
          }
        }

        function gameLoop(timestamp) {
          if (!lastTimestamp) lastTimestamp = timestamp;
          const delta = (timestamp - lastTimestamp) / 1000;
          lastTimestamp = timestamp;

          if (state.playing && !state.gameOver) {
            state.elapsed += delta;
            state.speed = state.baseSpeed + state.elapsed * 0.55;
            state.score += delta * 15;
            updatePlayer(delta);
            updateObstacles(delta);
            updateScoreboard();
          }
          requestAnimationFrame(gameLoop);
        }

        function handlePointer(e) {
          unlockAudio();
          e.preventDefault();
          jump();
        }

        function handleKey(e) {
          if (["Space", "ArrowUp", "KeyW"].includes(e.code)) {
            unlockAudio();
            e.preventDefault();
            jump();
          } else if (state.gameOver && e.code === "Enter") {
            unlockAudio();
            resetGame();
            startRun();
            playSound("retry");
          }
        }

        retryBtn.addEventListener("click", () => {
          unlockAudio();
          resetGame();
          startRun();
          playSound("retry");
        });

        gameArea.addEventListener("pointerdown", handlePointer);
        window.addEventListener("keydown", handleKey);

        window.addEventListener("resize", () => {
          syncPlayerX();
        });

        resetGame();
        requestAnimationFrame(gameLoop);
      })();
    </script>
  </body>
</html>
